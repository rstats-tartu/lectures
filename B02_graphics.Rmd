---
title: "Graphics 2017"
output:
  html_document: default
  html_notebook: default
---



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, error=FALSE, message=FALSE, warning = FALSE)
```


```{r }
library(tidyverse)
library(ggthemes)
iris<-as_tibble(iris)
iris
```

We are looking at the Iris dataset
```{r}
summary(iris)
```

#Lets start with base graphics

we use them for quick plots, not usually for publication level plots (for this we use ggplot2 package).

##Stripchart

A simple way to plot the values is stripchart
```{r}
stripchart(iris$Sepal.Length)
```


```{r}
plot(iris$Species)
plot(iris$Sepal.Length) #Scatterplots can be created using `plot()`. If we use `plot()` command with only one variable, we get graph with values versus index. Index corresponds to rownumber in the iris table We can use this representation to find out where we have gross outliers in our variable.
plot(iris$Species, iris$Sepal.Length)
plot(iris$Sepal.Length, iris$Sepal.Width)
plot(iris$Sepal.Length, iris$Sepal.Width, col=iris$Species)
plot(iris$Sepal.Length, iris$Sepal.Width)
abline(
  lm(iris$Sepal.Width~iris$Sepal.Length), 
  col="red", 
  lwd=2
  )

#conditioning plot
coplot(iris$Sepal.Length ~ iris$Sepal.Width | iris$Species)
coplot(iris$Sepal.Length ~ iris$Sepal.Width | iris$Petal.Length)
coplot(iris$Sepal.Length ~ iris$Sepal.Width | iris$Species + iris$Petal.Length)

```
```{r}
plot(iris$Sepal.Length, iris$Sepal.Width, 
     col = iris$Species, # dots are colored by species
     pch = 16, # we use filled dots instead of default empty dots
     xlab = "sepal length", #x axis label
     ylab = "petal length", #y axis label
     main = "Iris" #graph label
)
      
palette()
legend("topright", # we place legend to the top right corner of the plot
       legend = levels(iris$Species), # species names in the legend
       pch = 16, # dot shape
       bty = "n", # the type of box to be drawn around the legend: "n" no box
       col = 1:3) # new colors are added with numbers 1 to 3. 
```

##Histogram

```{r}
hist(iris$Sepal.Length)
```

With histograms you want to vary the binwidth. The argument **breaks** does that

```{r}
hist(iris$Sepal.Length,
     freq = FALSE, #if TRUE, the histogram graphic is a representation of frequencies, the counts component of the result; if FALSE, probability densities are plotted so that the histogram has a total area of one
     col="red",
     breaks = 15,
     xlim = c(3, 9), #limits the X axis from 3 to 9
     ylim = c(0, 0.6), #limits the Y axis from 0 to 0.6
     main = "Iris",
     xlab = "sepal length")

abline(v = median(iris$Sepal.Length), col = "blue", lwd = 2)
abline(h = 0.3, col = "cyan", lwd = 2)
```
note that 19 bins were made from 15 breaks.

An alternative breaks assignment
```{r}
hist(iris$Sepal.Length, breaks = seq(4, 9, by = 0.25))
```


see: ?seq






###Plot all variable pairs into a matrix of scatterplots

iris[,1:4] means the columns 1 to 4 of the iris table. In R [,] means index, where  the numbers left of the comma specify table rows and the numbers right of the comma specify columns. If there is no number, this simply means "all rows" or "all columns". So iris[1,2] selects a single cell (first row, second column), iris[c(1,3), 2:4] selects the first and third rows of columns 2 to 4, and so on.
NB! In R index numbers start from 1 (not 0).

```{r}
plot(iris[,1:4], 
      main = "Iris Dataset",
      pch = 21, # dots need to be big enough to display color
      bg = iris$Species) # color by species
```
 
 `bg=` arguments gives us color for dots background.


#ggplot 

**ggplot2** is an R package for producing statistical graphics based on the grammar of graphics (hence the gg!).

+ **ggplot2 works iteratively** -- you start with a layer showing the raw data and then add layers of geoms, annotations, and statistical summaries.

To compose plots, you have to supply minimally:

+ **Data** that you want to visualise and **aes**thetic mappings -- what's on x-axis, what's on y-axis, and how to you want to group and color your data.


1. you start by piping in the data
2. then you say, wich variable goes to which axis - this goes into aes()
3. then you say, which kind of graph or graphs do you want to draw on these axes
4. then you say, which continuous variables will be split by which factor levels
5. and finally you modify the appearance of your graph

                    
1.                    
```{r}
iris %>% ggplot()
```
 draws empty plot
 
 2
```{r}
iris %>% ggplot(aes(x=Sepal.Length, y=Sepal.Width))
```
adds x and y axes

3
```{r}
iris %>% ggplot(aes(x=Sepal.Length, y=Sepal.Width)) + 
  geom_point() + 
  geom_smooth(method = "lm")
```
adds the graphing elements (points and a regression line with standard error)

4
```{r}
iris %>% ggplot(aes(x=Sepal.Length, y=Sepal.Width)) +
  geom_point(aes(color=Species)) + 
  geom_smooth(method = "lm")
```
splits and colors the data by species - but only for the points. try out what happens if you make the split in ggplot( aes())

```{r}
iris %>% ggplot(aes(x=Sepal.Length, y=Sepal.Width)) +
  geom_point(aes(color=Species)) + 
  geom_smooth(method = "lm", color="black", se=FALSE) +
  theme_classic()
```
Adds beauty points by changing the theme and removing standard error


You can further adjust your plot:

+ by adding **statistical summaries** of your raw data.
+ using **scale**s to redraw a legend or axes.
+ using **facet**ing to break up the data into subsets for display.





```{r}
ggplot(iris, aes(x=Sepal.Length, y=Sepal.Width)) +
  geom_point() +
  geom_smooth(data=filter(iris, Species =="setosa"), method = lm) 
  theme_classic()
```


```{r}
ggplot(iris, aes(x=Sepal.Length, y=Sepal.Width)) +
  geom_point() +
  geom_smooth(data=filter(iris, Species %in% c("virginica", "versicolor")), method = lm) + 
  theme_bw()
```

```{r}
ggplot(iris, aes(x=Sepal.Length, y=Sepal.Width, color=Species)) +
  geom_point() +
  geom_smooth(method = "lm", se=F) +
  theme_tufte()
```

####weigthed linear model


model coefficients weighted by the variable *total population*
```{r}

ggplot(midwest, aes(percwhite, percbelowpoverty)) +
  geom_point(aes(size = poptotal)) +
  geom_smooth(aes(weight = poptotal), method = lm, size = 1) + 
  geom_smooth(method = lm, color="red") +
  labs(x="percent white", y="percent below poverty")
```

Note that aes() works also inside geom_

```{r}
ggplot(iris) +
  geom_point(aes(x=Sepal.Length, y=Sepal.Width, size = Petal.Length, color= Species))
```

What happens if we take color out of aes()?
```{r}
ggplot(iris) +
  geom_point(aes(x=Sepal.Length, y=Sepal.Width, size = Petal.Length), color= "red")
```

**One common problem is to put the + in the wrong place: it has to come at the end of the line, not the start.**


A trick: lets use two datasets inside a single figure:
```{r}
head(mpg, 2)
mpg<-mpg

best_in_class <- mpg %>%
  group_by(class) %>%
  top_n(1, hwy)

head(best_in_class)
```


we add a separate dataset for the geom_point() layer.
Thus we add hollow points only to best-in-class cars

```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class))+
  geom_point(size = 3, shape = 1, data = best_in_class) 
```

**add text labels for the best-in-class datapoints**
```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class))+
  geom_point(size = 3, shape = 1, data = best_in_class) +
  ggrepel::geom_label_repel(aes(label = model), data = best_in_class, cex=2)

```


##Faceting

In graphing several variables or subsets thereof you have 2 basic options. 1. group the measurement Vars by a non-measurement variable and then use color, fill, etc. to label several groups and put them all onto the **same** panel 
```{r}
#here we separate different classes of cars into different colors
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class))
```

or 2. group measurement Vars by a non-measurement variable and use faceting to put different groups onto **different** panels. There are two alternative faceting methods: facet_wrap() and facet_grid(). 

```{r}
ggplot(mpg, aes(displ, hwy)) +
   geom_point()+
  facet_wrap(~class, nrow=2)
```

```{r}
ggplot(mpg, aes(displ, hwy)) +
   geom_point()+
  facet_wrap(~drv, ncol=1)
```


If we want to facet by 2 variables: facet_grid

```{r}
ggplot(mpg, aes(displ, hwy)) +
   geom_point()+
  facet_grid(drv ~ cyl)
```

drv --- drive - 4(-wheel), f(orward), r(ear)
cyl --- cylinders - 4, 5, 6, or 8

By using a dot in the equations you can set the facets side-by-side (.~var) or on top of each other (var~.)

```{r}
ggplot(mpg, aes(displ, hwy)) +
   geom_point()+
  facet_grid(. ~ drv)
```

```{r}
ggplot(mpg, aes(displ, hwy)) +
   geom_point()+
  facet_grid(drv ~ .)
```



####Coordinate systems 

```{r}
ggplot(iris, mapping = aes(x = Species, y = Sepal.Length)) + 
  geom_boxplot()
```

```{r}
ggplot(iris, mapping = aes(x = Species, y = Sepal.Length)) + 
  geom_boxplot() +
  coord_flip()
```

####reverse the y axis and take the square root of x axis (2 layers)
```{r, eval=FALSE}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class))+
  scale_y_reverse() + 
  scale_x_sqrt()

```

####change the breaks at y axis
```{r, eval=FALSE}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class))+
  scale_y_continuous(breaks = seq(15, 40, by = 5))

```


###titles and  axes labels 

```{r}
a1 <- ggplot(iris, aes(Sepal.Length, Sepal.Width, color = Species)) + 
  geom_point()

a1 + labs(
     title = "Title",
     subtitle = "subtitle",
     caption = "caption"
      )
```

use labs to change axis labels and legend title
```{r}
a1 + labs(
     x = "Length",
     y = "Width",
     color = "Iris sp."
     )
```

#### Remove the axis labels with NULL
```{r, eval=FALSE}
a1 +
  xlab(NULL) +
  ylab(NULL)
```

ggtitle() - adds title to plot

####legend not transparent, while geom is.
```{r, eval=FALSE}
norm <- tibble(x = rnorm(1000), y = rnorm(1000))
norm$z <- cut(norm$x, 3, labels = c( "a" ,  "b" ,  "c" )) #creates a new column

ggplot(norm, aes(x, y)) +
  geom_point(aes(colour = z), alpha = 0.3) +
  guides(colour = guide_legend(override.aes = list(alpha = 1)))
```

###legend inside the plot
```{r, eval=FALSE}
df <- data.frame(x = 1:3, y = 1:3, z = c( "a" ,  "b" ,  "c" ))
base <- ggplot(df, aes(x, y)) +
  geom_point(aes(colour = z), size = 3) +
  xlab(NULL) +
  ylab(NULL)

base + theme(legend.position = c(0, 1), legend.justification = c(0, 1))
base + theme(legend.position = c(0.5, 0.5), legend.justification = c(0.5, 0.5))
base + theme(legend.position = c(1, 0), legend.justification = c(1, 0))

```


ggplot2 automatically adds default scales behind the scenes:

```{r, eval=FALSE}
  scale_x_continuous() +
  scale_y_continuous() +
  scale_colour_discrete()
``` 
  
You can make them explicit and add arguments:
```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  scale_y_continuous(breaks = seq(15, 40, by = 5))
```

You can use labels in the same way (a character vector the same length as breaks), but you can also set it to NULL to suppress the labels altogether. 

```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  scale_x_continuous(labels = NULL) +
  scale_y_continuous(labels = NULL)
```

**the angle of axis labels**

```{r, eval=FALSE}
theme(axis.text.x = element_text(angle=90, hjust=1, vjust=0.5))
```

**reverse the y axis and take the square root of x axis (2 layers)**
```{r, eval=FALSE}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class))+
  scale_y_reverse() + 
  scale_x_sqrt()

```


legend position:
```{r, eval=FALSE}
base + theme(legend.position = "left")
base + theme(legend.position = "top")
base + theme(legend.position = "bottom")
base + theme(legend.position = "right") # the default
```

###remove the legend
```{r, eval=FALSE}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class))+
  theme(legend.position = "none")

```


you can replace the scale altogether. There are two types of scales you’re mostly likely to want to switch out: continuous position scales and colour scales. 

```{r}
ggplot(diamonds, aes(log10(carat), log10(price))) +
  geom_bin2d()
```

the disadvantage of this transformation is that the axes are now labelled with the transformed values, making it hard to interpret the plot. Instead of doing the transformation in the aesthetic mapping, we can instead do it with the scale. This is visually identical, except the axes are labelled on the original data scale.

```{r}
ggplot(diamonds, aes(carat, price)) +
  geom_bin2d() + 
  scale_x_log10() + 
  scale_y_log10()
```

##Color scale

Another scale that is frequently customised is colour.
ColorBrewer scales work better for people with colour blindness. 
```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = drv)) +
  scale_colour_brewer(palette = "Set1")
```

The ColorBrewer scales are documented online at http://colorbrewer2.org/ and made available in R via the RColorBrewer package. When you have a predefined mapping between values and colours, use scale_colour_manual(). 

scale_colour_manual(values = c(factor_level_1 = "red", factor_level_2 = "blue")

scale_colour_viridis() provided by the viridis package is a continuous analog of the categorical ColorBrewer scales.

For continuous colour, you can use the built-in scale_colour_gradient() or scale_fill_gradient(). If you have a diverging scale, you can use scale_colour_gradient2(). That allows you to give, for example, positive and negative values different colours. That’s sometimes also useful if you want to distinguish points above or below the mean.

####colors for continuos vars
```{r}
df <- data.frame(x = 1, y = 1:5, z = c(1, 3, 2, NA, 5))
p <- ggplot(df, aes(x, y)) + geom_tile(aes(fill = z), size = 5)
p
# Make missing colours invisible
p + scale_fill_gradient(na.value = NA)
# Customise on a black and white scale
p + scale_fill_gradient(low =  "black" , high =  "white" , na.value =  "red" )
```

####colors for discrete data
There are four colour scales for discrete data. We illustrate them with a barchart that encodes both position and fill to the same variable.    
The default colour scheme, scale colour hue(), picks evenly spaced hues around the HCL colour wheel. This works well for up to about eight colours, but after that it becomes hard to tell the di↵erent colours apart. You can control the default chroma and luminance, and the range of hues, with the h, c and l arguments:

```{r}
df <- data.frame(x = c( "a" ,  "b" ,  "c" ,  "d" ), y = c(3, 4, 1, 2))
bars <- ggplot(df, aes(x, y, fill = x)) +
  geom_bar(stat =  "identity" ) +
  labs(x = NULL, y = NULL) +
  theme(legend.position =  "none" )
bars
bars + scale_fill_hue(c = 40)
bars + scale_fill_hue(h = c(180, 300))
bars + scale_fill_brewer(palette =  "Set1" )
bars + scale_fill_brewer(palette =  "Set2" )
bars + scale_fill_brewer(palette =  "Accent" )
bars + scale_fill_grey()
bars + scale_fill_grey(start = 0.5, end = 1)
bars + scale_fill_grey(start = 0, end = 0.5)

```


##Zooming

There are three ways to control the plot limits:

1. Adjusting what data are plotted
2. Setting the limits in each scale
3. Setting xlim and ylim in coord_cartesian()

To zoom in on a region of the plot: coord_cartesian().

*coord_cartesian(xlim = c(5, 7), ylim = c(10, 30))*

**You can also set the limits on individual scales.** Reducing the limits is like subsetting the data. It is more useful if you want expand the limits, for example, to match scales across different plots. 
  For example, if we extract two classes of cars and plot them separately, it’s difficult to compare the plots because all three scales (the x-axis, the y-axis, and the colour aesthetic) have different ranges.

*scale_x_continuous(limits = range(mpg$displ))*

*scale_y_continuous(limits = range(mpg$hwy))*

*scale_colour_discrete(limits = unique(mpg$drv))*



